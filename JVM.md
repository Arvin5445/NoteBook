# 1. 内存模型



# 2. GC



## 垃圾识别：

什么是垃圾：内存中不在被使用到的空间就是垃圾

判断对象时垃圾的方法：

### 1. 引用计数法

一个对象被引用其引用值就+1，取消引用就-1，很难解决循环引用的问题

### 2. 可达性分析法

根搜索算法的基本思路就是通过一系列名为”GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。这个算法的基本思想是通过一系列称为“GC Roots”的对象作为起始点，从这些节点向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链（即GC Roots到对象不可达）时，则证明此对象是不可用的。

![img](https://img-blog.csdnimg.cn/20190506204803732.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NjI1NzU3,size_16,color_FFFFFF,t_70)


哪些对象可以作为GC Roots

虚拟机栈（栈帧中的局部变量区，也叫做局部变量表）中引用的对象。
方法区中的类静态属性引用的对象。
方法区中常量引用的对象。
本地方法栈中JNI(Native方法)引用的对象。



## 垃圾回收：

 ==JVM采用 **“分代收集”**（Generational Collection）算法==

==**新生代**对象存活率低，有老年代给它担保，一般使用复制算法==

==**老年代**对象存活率高，没有额外空间对它进行分配担保，一般是由标记清除或者是标记清除（多次）与标记整理（一次）的混合实现==

### 1. 引用计数法（JVM 不使用）

+ 什么是引用计数法？
         	 所谓的引用计数法就是给每个对象一个引用计数器，每当有一个地方引用它时，计数器就会加1；当引用失效时，计数器的值就会减1；任何时刻计数器的值为0的对象就是不可能再被使用的。

      ​		这个引用计数法时没有被Java所使用的，但是python有使用到它。而且最原始的引用计数法没有用到GC Roots。

+ 优点
  1. 可即时回收垃圾：在该方法中，每个对象始终知道自己是否有被引用，当被引用的数值为0时，对象马上可以把自己当作空闲空间链接到空闲链表。

  2. 最大暂停时间短。

  3. 没有必要沿着指针查找

+ 缺点

  1. 计数器值的增减处理非常繁重
2. 计算器需要占用很多位。
  3. 实现繁琐。
4. 循环引用无法回收。



### 2. 标记 - 清除算法（老年代）

​		**最基础的收集算法是“标记-清除”（Mark-Sweep）算法，如同它的名字一样，算法分 为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有 被标记的对象，它的标记过程其实在前一节讲述对象标记判定时已经介绍过了。之所以说它 是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其不足进行改进而得到的。**

> 当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为Stop The World），然后进行两项工作，第一项则是标记，第二项则是清除。
>
> **标记：**从引用根节点开始标记所有被引用的对象。标记的过程其实就是遍历所有的GC Roots，然后将所有GC Roots可达的对象标记为存活的对象。
>
> **清除：**遍历整个堆，把未标记的对象清除。

+ 优点

	1. 实现简单

	2. 与保守式GC算法兼容（保守式GC在后面介绍）

	3. 不需要双倍的内存空间。

+ 缺点

  1. **效率比较低**（递归与全堆对象遍历），而且在进行GC的时候，需要停止应用程序，这会导致用户体验非常差劲：一个是效率问题，标记和清除两个过程的效率都不高

  2. **碎片化**：如上图所示，在回收的过程中会产生被细化的分块，到后面，即使堆中分块的总大小够用，但是却因为分块太小而不能执行分配。这种方式清理出来的空闲内存是不连续的(内存碎片)，这点不难理解，我们的死亡对象都是随即的出现在内存的各个角落的，现在把它们清除之后，内存的布局自然会乱七八糟。而为了应付这一点，JVM就不得不维持一个内存的空闲列表，这又是一种开销。而且在分配数组对象的时候，寻找连续的内存空间会不太好找。
  
     标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程 序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾 收集动作。标记—清除算法的执行过程如图3-2所示。
  
  3. **Stop The World**：此算法需要暂停整个应用，会产生内存碎片。用通俗的话解释一下标记/清除算法，就是当程序运行期间，若可以使用的内存被耗尽的时候，GC线程就会被触发并将程序暂停，随后将依旧存活的对象标记一遍，最终再将堆中所有没被标记的对象全部清除掉，接下来便让程序恢复运行。
  
  4. 分配速度：因为分块不是连续的，因此每次分块都要遍历空闲链表，找到足够大的分块，从而造成时间的浪费。
  
  5. 与写时复制技术不兼容：所谓写时复制就是fork的时候，内存空间只引用而不复制，只有当该进程的数据发生变化时，才会将数据复制到该进程的内存空间。这样，当两个进程中的内存数据相同的时候，就能节约大量的内存空间了。而对于标记-清除算法，它的每个对象都有一个标志位来表示它是否被标记，在每一次运行标记-清除算法的时候，被引用的对象都会进行标记操作，这个仅仅标记位的改变，也会变成对象数据的改变，从而引发写时复制的复制过程，与写时复制的初衷就背道而驰了。



### 3. 复制算法（新生代）
+ 什么是复制算法？
        	 复制算法就是将内存空间按容量分成两块。当这一块内存用完的时候，就将还存活着的对象复制到另外一块上面，然后把已经使用过的这一块一次清理掉。这样使得每次都是对半块内存进行内存回收。内存分配时就不用考虑内存碎片等复杂情况，只要移动堆顶的指针，按顺序分配内存即可，实现简单，运行高效。
          
     新生代分为一块Eden区和两块Survivor区（8 : 1 : 1）当一个对象创建的时候先进入的是Eden区。

> ​		Survivor区，一块叫From，一块叫To，对象存在Eden和From块。当进行GC时，Eden存活的对象全移到To块，而From中，存活的对象按年龄值确定去向，当达到一定值（年龄阈值，通过-XX:MaxTenuringThreshold可设置，默认15）的对象会移到年老代中，没有达到值的复制到To区，经过GC后，Eden和From被清空。（To区空间不够会找老年代作担保）
>
> ​		之后，From和To交换角色，新的From即为原来的To块，新的To块即为原来的From块，且新的To块中对象年龄加1。

+  担保机制

+ 优点
  1. 优秀的吞吐量，效率高，解决了标记的效率问题
  2. 复制算法**不会产生内存碎片**。
  3. 可实现高速分配：复制算法不用使用空闲链表。这是因为分块是连续的内存空间，因此，调用这个分块的大小，只需要这个分块大小不小于所申请的大小，移动指针进行分配即可。
  4. 与缓存兼容。

+ 缺点
  1. 堆的使用效率低下。（**浪费空间**）它浪费了一半的内存
  2. 不兼容保守式GC算法。
  3. 递归调用函数。



### 4. 标记 - 整理算法（老年代）

​		**标记过程 仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存 活的对象都向一端移动，然后直接清理掉端边界以外的内存**

+ 优点
  1. 解决了标记清理算法的空间碎片化问题
+ 缺点
  1. 效率还是低



## Stop The World：

从GC Roots节点找引用链，要逐个检查这里面的引用，那么必然会消耗很多时间。

这项分析工作必须在一 个能确保一致性的快照中进行（**Stop The World）**

主流Java虚拟机使用的都是**准确式GC**

> ​		当执行系统停顿下来后，并不需要一个不漏地检查完所有 执行上下文和全局的引用位置，虚拟机应当是有办法直接得知哪些地方存放着对象引用。在 HotSpot的实现中，是使用一组称为**OopMap**的数据结构来达到这个目的的，在类加载完成的 时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在**特定的位置**记录下栈和寄存器中哪些位置是引用。这样，GC在扫描时就可以直接得知 这些信息了。

### 1. 安全点

> ​		在OopMap的协助下，HotSpot可以快速且准确地完成GC Roots枚举，但一个很现实的问 题随之而来：可能导致引用关系变化，或者说OopMap内容变化的指令非常多，如果为每一 条指令都生成对应的OopMap，那将会需要大量的额外空间，这样GC的空间成本将会变得很 高。
>
> ​		实际上，HotSpot也的确没有为每条指令都生成OopMap，前面已经提到，只是在“特定的 位置”记录了这些信息，这些位置称为安全点（Safepoint），即程序执行时并非在所有地方都 能停顿下来开始GC，只有在到达安全点时才能暂停。Safepoint的选定既不能太少以致于让 GC等待时间太长，也不能过于频繁以致于过分增大运行时的负荷。所以，安全点的选定基 本上是以程序“是否具有让程序长时间执行的特征”为标准进行选定的——因为每条指令执行 的时间都非常短暂，程序不太可能因为指令流长度太长这个原因而过长时间运行，“长时间 执行”的最明显特征就是指令序列复用，例如方法调用、循环跳转、异常跳转等，所以具有 这些功能的指令才会产生Safepoint。
>
> ​		对于Sefepoint，另一个需要考虑的问题是如何在GC发生时让所有线程（这里不包括执行 JNI调用的线程）都“跑”到最近的安全点上再停顿下来。这里有两种方案可供选择：抢先式 中断（Preemptive Suspension）和主动式中断（Voluntary Suspension），其中抢先式中断不需 要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程 中断的地方不在安全点上，就恢复线程，让它“跑”到安全点上。现在几乎没有虚拟机实现采 用抢先式中断来暂停线程从而响应GC事件。
>
> ​		而主动式中断的思想是当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设 置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。 轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。下面代码清 单3-4中的test指令是HotSpot生成的轮询指令，当需要暂停线程时，虚拟机把0x160100的内存 页设置为不可读，线程执行到test指令时就会产生一个自陷异常信号，在预先注册的异常处 理器中暂停线程实现等待，这样一条汇编指令便完成安全点轮询和触发线程中断。

### 2. 安全区

> ​		使用Safepoint似乎已经完美地解决了如何进入GC的问题，但实际情况却并不一定。 Safepoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint。但是， 程序“不执行”的时候呢？所谓的程序不执行就是没有分配CPU时间，典型的例子就是线程处 于Sleep状态或者Blocked状态，这时候线程无法响应JVM的中断请求，“走”到安全的地方去 中断挂起，JVM也显然不太可能等待线程重新被分配CPU时间。对于这种情况，就需要安全 区域（Safe Region）来解决。
>
> ​		安全区域是指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方 开始GC都是安全的。我们也可以把Safe Region看做是被扩展了的Safepoint。
>
> ​		在线程执行到Safe Region中的代码时，首先标识自己已经进入了Safe Region，那样，当 在这段时间里JVM要发起GC时，就不用管标识自己为Safe Region状态的线程了。在线程要离 开Safe Region时，它要检查系统是否已经完成了根节点枚举（或者是整个GC过程），如果完 成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开Safe Region的信号为 止。



## GC收集器

> ​		在JDK 1.5时期，HotSpot推出了一款在强交互应用中几乎可认为有划时代意义的垃圾收集器——**CMS**收 集器（Concurrent Mark Sweep，本节稍后将详细介绍这款收集器），这款收集器是HotSpot虚 拟机中第一款真正意义上的并发（Concurrent）收集器，它第一次实现了让垃圾收集线程与 用户线程（基本上）同时工作，用前面那个例子的话来说，就是做到了在你的妈妈打扫房间 的时候你还能一边往地上扔纸屑。
>
> ​		不幸的是，CMS作为老年代的收集器，却无法与JDK 1.4.0中已经存在的新生代收集器 Parallel Scavenge配合工作（Parallel Scavenge收集器及G1收集器都没有使用传统的GC收集器代码框架，而是另外独立实现，其余几种收集器则共用了部分的框架代码），所以在JDK 1.5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者Serial收集器中的一个。

### 1. Parallel Scavenge收集器：

> ​		Parallel Scavenge收集器是一个==**新生代**==收集器，它也是使用**==复制算法==**的收集器，又是**并行的多线程**收集器……看上去和ParNew都一样，那它有什么特别之处呢？
>
> ​		Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，==**CMS等收集器的关注点 是尽可能地缩短垃圾收集时用户线程的停顿时间**，而**Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量**==（Throughput）。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总 消耗时间的比值，即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间），虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。
>
> ​		停顿时间越短就越**适合需要与用户交互的程序**，良好的响应速度能提升用户体验，而高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不 需要太多交互的任务。
>
> ​		Parallel Scavenge收集器提供了**两个参数用于精确控制吞吐量**，分别是控制最大垃圾收集停顿时间的-XX：MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX：GCTimeRatio参 数。
>
> ​		MaxGCPauseMillis参数允许的值是一个大于0的毫秒数，收集器将尽可能地保证内存回 收花费的时间不超过设定值。不过大家不要认为如果把这个参数的值设置得稍小一点就能使 得系统的垃圾收集速度变得更快，GC停顿时间缩短是以牺牲吞吐量和新生代空间来换的：系统把新生代调小一些，收集300MB新生代肯定比收集500MB快吧，这也直接导致垃圾 收集发生得更频繁一些，原来10秒收集一次、每次停顿100毫秒，现在变成5秒收集一次、每 次停顿70毫秒。停顿时间的确在下降，但吞吐量也降下来了。
>
> ​		GCTimeRatio参数的值应当是一个大于0且小于100的整数，也就是垃圾收集时间占总时 间的比率，相当于是吞吐量的倒数。如果把此参数设置为19，那允许的最大GC时间就占总 时间的5%（即1/（1+19）），默认值为99，就是允许最大1%（即1/（1+99））的垃圾收集 时间。
>
> ​		由于与吞吐量关系密切，Parallel Scavenge收集器也经常称为**“吞吐量优先”收集器**。除上 述两个参数之外，Parallel Scavenge收集器还有一个参数-XX：+UseAdaptiveSizePolicy值得关 注。这是一个开关参数，当这个参数打开之后，就不需要手工指定新生代的大小（-Xmn）、 Eden与Survivor区的比例（-XX：SurvivorRatio）、晋升老年代对象年龄（-XX： PretenureSizeThreshold）等细节参数了，虚拟机会**根据当前系统的运行情况收集性能监控信息，动态调整这些参数**以提供最合适的停顿时间或者最大的吞吐量，这种调节方式称为GC 自适应的调节策略（GC Ergonomics） 。如果读者对于收集器运作原来不太了解，手工优化存在困难的时候，使用Parallel Scavenge收集器配合自适应调节策略，把内存管理的调优任务 交给虚拟机去完成将是一个不错的选择。只需要把基本的内存数据设置好（如-Xmx设置最大 堆），然后使用MaxGCPauseMillis参数（更关注最大停顿时间）或GCTimeRatio（更关注吞 吐量）参数给虚拟机设立一个优化目标，那具体细节参数的调节工作就由虚拟机完成了。自 适应调节策略也是Parallel Scavenge收集器与ParNew收集器的一个重要区别。



### 2. Parallel Old收集器

> Parallel Old是Parallel Scavenge收集器的老年代版本，使用==**多线程**==和==**“标记-整理”**==算法。 这个收集器是在JDK 1.6中才开始提供的，在此之前，新生代的Parallel Scavenge收集器一直 处于比较尴尬的状态。原因是，如果新生代选择了Parallel Scavenge收集器，老年代除了 Serial Old（PS MarkSweep）收集器外别无选择（还记得上面说过Parallel Scavenge收集器无 法与CMS收集器配合工作吗？）。由于老年代Serial Old收集器在服务端应用性能上的“拖 累”，使用了Parallel Scavenge收集器也未必能在整体应用上获得吞吐量最大化的效果，由于 单线程的老年代收集中无法充分利用服务器多CPU的处理能力，在老年代很大而且硬件比较 高级的环境中，这种组合的吞吐量甚至还不一定有ParNew加CMS的组合“给力”。
>
> 直到Parallel Old收集器出现后，==**“吞吐量优先”收集器**==终于有了比较名副其实的应用组合，在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old 收集器。Parallel Old收集器的工作过程如图3-9所示。

![image-20200315154024439](/Users/arvin/Library/Application Support/typora-user-images/image-20200315154024439.png)



# 3. 类加载



# 4. 内存中的对象



# 5. 并发 & 锁



# 6. JVM调优参数



> -X ：非标准选项
>
> -XX：非稳定选项
>
>  
>
> 在选项名前用 “+” 或 “-” 表示开启或关闭特定的选项，例：
>
>   -XX:+UseCompressedOops：表示开启 压缩指针
>
>   -XX:-UseCompressedOops：表示关闭 压缩指针



+ -XX:+PrintGCApplicationStoppedTime 会打出系统停止的时间
+ -XX:+PrintSafepointStatistics -XX:PrintSafepointStatisticsCount=1 这两个参数会打印出详细信息

1.堆分配参数
-Xmn10M：设置新生代区域大小为10M

-XX:NewSize=2M：设置新生代初始大小为2M

-XX:MaxNewSize=2M：设置新生代最大值为2M

（如果以上三个同时设置了，谁在后面谁生效。生产环境使用-Xmn即可，避免抖动）

==-Xms128M：设置java程序启动时堆内存128M（默认为物理内存1/64,且小于1G）==

==-Xmx256M：设置最大堆内存256M，超出后会出现 OutOfMemoryError（默认为物理内存1/64,且小于1G）==

（生产环境 -Xms 与 -Xmx 最好一样，避免抖动）
-Xss1M：设置线程栈的大小 1M（默认1M）

-XX:ThreadStackSize，-Xss 设置在后面，以-Xss为准；  -XX:ThreadStackSize设置在后面，主线程以 -Xss为准，其他线程以  -XX:ThreadStackSize为准

-XX:MinHeapFreeRatio=40：设置堆空间最小空闲比例（默认40）（当-Xmx与-Xms相等时，该配置无效）

-XX:MaxHeapFreeRatio=70：设置堆空间最大空闲比例（默认70）（当-Xmx与-Xms相等时，该配置无效）

-XX:NewRatio=2：设置年轻代与年老代的比例为2:1

==-XX:SurvivorRatio=8：设置年轻代中eden区与survivor区的比例为8：1==

==-XX:MetaspaceSize=64M：设置元数据空间初始大小（取代-XX:PermSize）==

==-XX:MaxMetaspaceSize=128M：设置元数据空间最大值（取代之前-XX:MaxPermSize）==

-XX:TargetSurvivorRatio=50：设置survivor区使用率。当survivor区达到50%时，将对象送入老年代

-XX:+UseTLAB：在年轻代空间中使用本地线程分配缓冲区(TLAB)，默认开启

-XX:TLABSize=512k：设置TLAB大小为512k

-XX:+UseCompressedOops：使用压缩指针，默认开启

==-XX:MaxTenuringThreshold=15：对象进入老年代的年龄（Parallel是15，CMS是6）==

2.垃圾回收器相关
-XX:MaxGCPauseMillis：设置最大垃圾收集停顿时间（收集器工作时会调整其他参数大小，尽可能将停顿控制在指定时间内）

-XX:+UseAdaptiveSizePolicy：打开自适应GC策略（该摸式下，各项参数都会被自动调整）

 

-XX:+UseSerialGC：在年轻代和年老代使用串行回收器


-XX:+UseParallelGC：使用并行垃圾回收收集器，默认会同时启用 -XX:+UseParallelOldGC（默认使用该回收器）

-XX:+UseParallelOldGC：开启老年代使用并行垃圾收集器，默认会同时启用 -XX:+UseParallelGC

-XX:ParallelGCThreads=4：设置用于垃圾回收的线程数为4（默认与CPU数量相同）


-XX:+UseConcMarkSweepGC：使用CMS收集器（年老代）

-XX:CMSInitiatingOccupancyFraction=80：设置CMS收集器在年老代空间被使用多少后触发

-XX:+CMSClassUnloadingEnabled：允许对类元数据进行回收

-XX:+UseCMSInitiatingOccupancyOnly：只在达到阈值的时候，才进行CMS回收


-XX:+UseG1GC：使用G1回收器

-XX:G1HeapRegionSize=16m：使用G1收集器时设置每个Region的大小（范围1M - 32M）

-XX:MaxGCPauseMillis=500 ：设置最大暂停时间（毫秒）


-XX:+DisableExplicitGC：禁止显示GC的调用（即禁止开发者的 System.gc();）

 

2.GC日志
-XX:+PrintGCDetails：打印GC信息

-XX:+PrintGCTimeStamps ：打印每次GC的时间戳（现在距离启动的时间长度）

-XX:+PrintGCDateStamps ：打印GC日期

-XX:+PrintHeapAtGC：每次GC时，打印堆信息

-Xloggc:/usr/local/tomcat/logs/gc.$$.log ：GC日志存放的位置


3.堆快照
-XX:+HeapDumpOnOutOfMemoryError：出现内存溢出时存储堆信息，配合 -XX:HeapDumpPath 使用

 

-XX:HeapDumpPath=/usr/local/tomcat/logs/oom.%t.log：堆快照存储位置

 

-XX:+UseLargePages：使用大页  

-XX:LargePageSizeInBytes=4m：指定大页的大小（必须为2的幂）

 

滚动日志记录
-XX:+UseGCLogFileRotation  ： 开启滚动日志记录
-XX:NumberOfGCLogFiles=5 ：滚动数量，命名为filename.0, filename.1 .....  filename.n-1,  然后再从filename.0 开始，并覆盖已经存在的文件
-XX:GCLogFileSize=8k  :  每个文件大小，当达到该指定大小时，会写入下一个文件
-Xloggc:/gc/log   ：日志文件位置