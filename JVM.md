# 1. 内存模型







# 2. GC



## 垃圾识别：

​		什么是垃圾：内存中不在被使用到的空间就是垃圾

​		判断对象时垃圾的方法：

### 1. 引用计数法（JVM 不使用）

​		一个对象被引用其引用值就+1，取消引用就-1，很难解决循环引用的问题

### 2. 可达性分析法（JVM 使用）

​		根搜索算法的基本思路就是通过一系列名为”GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。这个算法的基本思想是通过一系列称为“GC Roots”的对象作为起始点，从这些节点向下搜索**（会引起Stop The World）**，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链（即GC Roots到对象不可达）时，则证明此对象是不可用的。

![img](https://img-blog.csdnimg.cn/20190506204803732.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NjI1NzU3,size_16,color_FFFFFF,t_70)


哪些对象可以作为GC Roots

虚拟机栈（栈帧中的局部变量区，也叫做局部变量表）中引用的对象。
方法区中的类静态属性引用的对象。
方法区中常量引用的对象。
本地方法栈中JNI(Native方法)引用的对象。



## 垃圾回收：

 ==JVM采用 **“分代收集”**（Generational Collection）算法==

==**新生代**对象存活率低，有老年代给它担保，一般使用复制算法==

==**老年代**对象存活率高，没有额外空间对它进行分配担保，一般是由标记清除或者是标记清除（多次）与标记整理（一次）的混合实现==



+ 回收过程

> ​		即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处 于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历==**两次标记过程**==：如果对象在进行可达 性分析后发现没有与GC Roots相连接的引用链，那它将会被**第一次标记**并且进行一次筛选， 筛选的条件是此对象是否有必要执行finalize（）方法。当对象没有覆盖finalize（）方法，或 者finalize（）方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。
>
> ​		如果这个对象被判定为有必要执行finalize（）方法，那么这个对象将会放置在一个叫做 F-Queue的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行 它。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束，这样做 的原因是，如果一个对象在finalize（）方法中执行缓慢，或者发生了死循环（更极端的情 况），将很可能会导致F-Queue队列中其他对象永久处于等待，甚至导致整个内存回收系统 崩溃。finalize（）方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行**第二次小规模的标记**，如果对象要在finalize（）中成功拯救自己——只要重新与引用链 上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或者对象的 成员变量，那在第二次标记时它将被移除出“即将回收”的集合；如果对象这时候还没有逃 脱，那基本上它就真的被回收了。从代码清单3-2中我们可以看到一个对象的finalize（）被 执行，但是它仍然可以存活。



+ 回收方法区

> ​		方法区中进行垃圾收集 的“性价比”一般比较低：在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以 回收70%～95%的空间，而永久代的垃圾收集效率远低于此
>
> 1. **收集废弃常量**
>
>    ​		回收废弃常量与回收 Java堆中的对象非常类似。以常量池中字面量的回收为例，假如一个字符串“abc”已经进入了 常量池中，但是当前系统没有任何一个String对象是叫做“abc”的，换句话说，就是没有任何 String对象引用常量池中的“abc”常量，也没有其他地方引用了这个字面量，如果这时发生内 存回收，而且必要的话，这个“abc”常量就会被系统清理出常量池。常量池中的其他类（接 口）、方法、字段的符号引用也与此类似。
>
> 2. **收集无用的类**
>
>    类需要同时满足下面3个条件才能算是“无用的类”：
>
>    + 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。
>
>    + 加载该类的ClassLoader已经被回收。
>
>    + 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
>
>    虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是 和对象一样，不使用了就必然会回收。是否对类进行回收，HotSpot虚拟机提供了-Xnoclassgc 参数进行控制，还可以使用-verbose：class以及-XX：+TraceClassLoading、-XX： +TraceClassUnLoading查看类加载和卸载信息，其中-verbose：class和-XX： +TraceClassLoading可以在Product版的虚拟机中使用，-XX：+TraceClassUnLoading参数需要 FastDebug版的虚拟机支持。
>
>    在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁 自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。



### 1. 引用计数法（JVM 不使用）

+ 什么是引用计数法？
         	 所谓的引用计数法就是给每个对象一个引用计数器，每当有一个地方引用它时，计数器就会加1；当引用失效时，计数器的值就会减1；任何时刻计数器的值为0的对象就是不可能再被使用的。

      ​		这个引用计数法时没有被Java所使用的，但是python有使用到它。而且最原始的引用计数法没有用到GC Roots。

+ 优点
  1. 可即时回收垃圾：在该方法中，每个对象始终知道自己是否有被引用，当被引用的数值为0时，对象马上可以把自己当作空闲空间链接到空闲链表。

  2. 最大暂停时间短。

  3. 没有必要沿着指针查找

+ 缺点

  1. 计数器值的增减处理非常繁重
  2. 计算器需要占用很多位。
  3. 实现繁琐。
  4. 循环引用无法回收。



### 2. 标记 - 清除算法（老年代）

​		**最基础的收集算法是“标记-清除”（Mark-Sweep）算法，如同它的名字一样，算法分 为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有 被标记的对象，它的标记过程其实在前一节讲述对象标记判定时已经介绍过了。之所以说它 是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其不足进行改进而得到的。**

> 当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为Stop The World），然后进行两项工作，第一项则是标记，第二项则是清除。
>
> **标记：**从引用根节点开始标记所有被引用的对象。标记的过程其实就是遍历所有的GC Roots，然后将所有GC Roots可达的对象标记为存活的对象。
>
> **清除：**遍历整个堆，把未标记的对象清除。

+ 优点

	1. 实现简单

	2. 与保守式GC算法兼容（保守式GC在后面介绍）

	3. 不需要双倍的内存空间。

+ 缺点

  1. **效率比较低**（递归与全堆对象遍历），而且在进行GC的时候，需要停止应用程序，这会导致用户体验非常差劲：一个是效率问题，标记和清除两个过程的效率都不高

  2. **碎片化**：如上图所示，在回收的过程中会产生被细化的分块，到后面，即使堆中分块的总大小够用，但是却因为分块太小而不能执行分配。这种方式清理出来的空闲内存是不连续的(内存碎片)，这点不难理解，我们的死亡对象都是随即的出现在内存的各个角落的，现在把它们清除之后，内存的布局自然会乱七八糟。而为了应付这一点，JVM就不得不维持一个内存的空闲列表，这又是一种开销。而且在分配数组对象的时候，寻找连续的内存空间会不太好找。
  
     标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程 序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾 收集动作。标记—清除算法的执行过程如图3-2所示。
  
  3. **Stop The World**：此算法需要暂停整个应用，会产生内存碎片。用通俗的话解释一下标记/清除算法，就是当程序运行期间，若可以使用的内存被耗尽的时候，GC线程就会被触发并将程序暂停，随后将依旧存活的对象标记一遍，最终再将堆中所有没被标记的对象全部清除掉，接下来便让程序恢复运行。
  
  4. 分配速度：因为分块不是连续的，因此每次分块都要遍历空闲链表，找到足够大的分块，从而造成时间的浪费。
  
  5. 与写时复制技术不兼容：所谓写时复制就是fork的时候，内存空间只引用而不复制，只有当该进程的数据发生变化时，才会将数据复制到该进程的内存空间。这样，当两个进程中的内存数据相同的时候，就能节约大量的内存空间了。而对于标记-清除算法，它的每个对象都有一个标志位来表示它是否被标记，在每一次运行标记-清除算法的时候，被引用的对象都会进行标记操作，这个仅仅标记位的改变，也会变成对象数据的改变，从而引发写时复制的复制过程，与写时复制的初衷就背道而驰了。



### 3. 复制算法（新生代）
+ 什么是复制算法？
        	 复制算法就是将内存空间按容量分成两块。当这一块内存用完的时候，就将还存活着的对象复制到另外一块上面，然后把已经使用过的这一块一次清理掉。这样使得每次都是对半块内存进行内存回收。内存分配时就不用考虑内存碎片等复杂情况，只要移动堆顶的指针，按顺序分配内存即可，实现简单，运行高效。
          
     新生代分为一块Eden区和两块Survivor区（8 : 1 : 1）当一个对象创建的时候先进入的是Eden区。

> ​		Survivor区，一块叫From，一块叫To，对象存在Eden和From块。当进行GC时，Eden存活的对象全移到To块，而From中，存活的对象按年龄值确定去向，当达到一定值（年龄阈值，通过-XX:MaxTenuringThreshold可设置，默认15）的对象会移到年老代中，没有达到值的复制到To区，经过GC后，Eden和From被清空。（To区空间不够会找老年代作担保）
>
> ​		之后，From和To交换角色，新的From即为原来的To块，新的To块即为原来的From块，且新的To块中对象年龄加1。
>
> ​		如果在Survivor空间中相同年龄所有对象大小的总 和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等 到MaxTenuringThreshold中要求的年龄

+  担保机制

> ​		虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看**HandlePromotionFailure**设置值是否允许担保失败。
>
> ​		如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的**平均大小**，如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。
>
> ​		如果某次Minor GC存活后的对象突增，远远高于平均值的话，依然会导致担保失败（Handle Promotion Failure）， 那就只好在失败后重新发起一次Full GC。
>
> ​		大部分情况下会将HandlePromotionFailure开关打开，避免Full GC过于频繁

+ 优点
  1. 优秀的吞吐量，效率高，解决了标记的效率问题
  2. 复制算法**不会产生内存碎片**。
  3. 可实现高速分配：复制算法不用使用空闲链表。这是因为分块是连续的内存空间，因此，调用这个分块的大小，只需要这个分块大小不小于所申请的大小，移动指针进行分配即可。
  4. 与缓存兼容。
+ 缺点
  1. 堆的使用效率低下。（**浪费空间**）它浪费了一半的内存
  2. 不兼容保守式GC算法。
  3. 递归调用函数。



### 4. 标记 - 整理算法（老年代）

​		**标记过程 仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存 活的对象都向一端移动，然后直接清理掉端边界以外的内存**

+ 优点
  1. 解决了标记清理算法的空间碎片化问题
+ 缺点
  1. 效率还是低







## Stop The World：

从GC Roots节点找引用链，要逐个检查这里面的引用，那么必然会消耗很多时间。

这项分析工作必须在一 个能确保一致性的快照中进行（**Stop The World）**

主流Java虚拟机使用的都是**准确式GC**

> ​		当执行系统停顿下来后，并不需要一个不漏地检查完所有 执行上下文和全局的引用位置，虚拟机应当是有办法直接得知哪些地方存放着对象引用。
>
> ​		在 HotSpot的实现中，是使用一组称为**OopMap**的数据结构来达到这个目的的，在类加载完成的 时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在**特定的位置**记录下栈和寄存器中哪些位置是引用。这样，GC在扫描时就可以直接得知 这些信息了。



### 1. 安全点

> ​		导致OopMap内容变化的指令非常多，如果为每一条指令都生成对应的OopMap，那将会需要大量的额外空间，这样GC的空间成本将会变得很高。
>
> ​		HotSpot也没有为每条指令都生成OopMap，只是在“特定的位置”记录了这些信息，这些位置称为**安全点（Safepoint）**，即程序执行时，==**只有在到达安全点时才能暂停**==。
>
> + Safepoint的选定不能太少以致于让 GC等待时间太长
>
> + 也不能过于频繁以致于过分增大运行时的负荷
>
> ​        安全点的选定基本上是以程序“是否具有让程序长时间执行的特征”为标准进行选定的，“长时间 执行”的最明显特征就是指令序列复用，例如方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才会产生Safepoint。
>
> ​		如何在GC发生时让所有线程（这里不包括执行 JNI调用的线程）都“跑”到最近的安全点上再停顿下来？
>
> + 抢先式中断（Preemptive Suspension）
>
> 其中抢先式中断不需 要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程 中断的地方不在安全点上，就恢复线程，让它“跑”到安全点上。现在几乎没有虚拟机实现采 用抢先式中断来暂停线程从而响应GC事件。
>
> + 和主动式中断（Voluntary Suspension）
>
> ​		而主动式中断的思想是当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设 置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。 轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。下面代码清 单3-4中的test指令是HotSpot生成的轮询指令，当需要暂停线程时，虚拟机把0x160100的内存 页设置为不可读，线程执行到test指令时就会产生一个自陷异常信号，在预先注册的异常处 理器中暂停线程实现等待，这样一条汇编指令便完成安全点轮询和触发线程中断。



### 2. 安全区

> ​		线程处 于Sleep状态或者Blocked状态，这时候线程无法响应JVM的中断请求，“走”到安全的地方去 中断挂起，JVM也显然不太可能等待线程重新被分配CPU时间。对于这种情况，就需要安全 区域（Safe Region）来解决。
>
> ​		**安全区域是指在一段代码片段之中，引用关系不会发生变化**。在这个区域中的任意地方 开始GC都是安全的。我们也可以把Safe Region看做是被扩展了的Safepoint。
>
> ​		在线程执行到Safe Region中的代码时，首先标识自己已经进入了Safe Region，在这段时间里JVM要发起GC时，就不用管标识自己为Safe Region状态的线程了。在线程要离 开Safe Region时，它要检查系统是否已经完成了根节点枚举（或者是整个GC过程），如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开Safe Region的信号为止。



### 3. 什么时候会STW（进入安全点）

- Garbage collection pauses（垃圾回收）
- JIT相关，比如Code deoptimization, Flushing code cache
- Class redefinition (e.g. javaagent，AOP代码植入的产生的instrumentation)
- Biased lock revocation 取消偏向锁
- Various debug operation (e.g. thread dump or deadlock check) dump 线程



## GC收集器：

> ​		在JDK 1.5时期，HotSpot推出了一款在强交互应用中几乎可认为有划时代意义的垃圾收集器——**CMS**收 集器（Concurrent Mark Sweep），它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。
>
> ​		CMS作为老年代的收集器，却无法与JDK 1.4.0中已经存在的新生代收集器 Parallel Scavenge配合工作（Parallel Scavenge收集器及G1收集器都没有使用传统的GC收集器代码框架，而是另外独立实现，其余几种收集器则共用了部分的框架代码），所以在JDK 1.5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者Serial收集器中的一个。

### 1. Parallel Scavenge

> ​		Parallel Scavenge收集器是一个==**新生代**==收集器，它也是使用**==复制算法==**的收集器，又是**并行的多线程**收集器……看上去和ParNew都一样，那它有什么特别之处呢？
>
> ​		Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，==**CMS等收集器的关注点 是尽可能地缩短垃圾收集时用户线程的停顿时间**，而**Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量**==（Throughput）。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总 消耗时间的比值，即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间），虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。
>
> ​		停顿时间越短就越**适合需要与用户交互的程序**，良好的响应速度能提升用户体验，而高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不 需要太多交互的任务。
>
> ​		Parallel Scavenge收集器提供了**两个参数用于精确控制吞吐量**，分别是控制最大垃圾收集停顿时间的-XX：MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX：GCTimeRatio参 数。
>
> ​		MaxGCPauseMillis参数允许的值是一个大于0的毫秒数，收集器将尽可能地保证内存回 收花费的时间不超过设定值。不过大家不要认为如果把这个参数的值设置得稍小一点就能使 得系统的垃圾收集速度变得更快，GC停顿时间缩短是以牺牲吞吐量和新生代空间来换的：系统把新生代调小一些，收集300MB新生代肯定比收集500MB快吧，这也直接导致垃圾 收集发生得更频繁一些，原来10秒收集一次、每次停顿100毫秒，现在变成5秒收集一次、每 次停顿70毫秒。停顿时间的确在下降，但吞吐量也降下来了。
>
> ​		GCTimeRatio参数的值应当是一个大于0且小于100的整数，也就是垃圾收集时间占总时 间的比率，相当于是吞吐量的倒数。如果把此参数设置为19，那允许的最大GC时间就占总 时间的5%（即1/（1+19）），默认值为99，就是允许最大1%（即1/（1+99））的垃圾收集 时间。
>
> ​		由于与吞吐量关系密切，Parallel Scavenge收集器也经常称为**“吞吐量优先”收集器**。除上 述两个参数之外，Parallel Scavenge收集器还有一个参数-XX：+UseAdaptiveSizePolicy值得关 注。这是一个开关参数，当这个参数打开之后，就不需要手工指定新生代的大小（-Xmn）、 Eden与Survivor区的比例（-XX：SurvivorRatio）、晋升老年代对象年龄（-XX： PretenureSizeThreshold）等细节参数了，虚拟机会**根据当前系统的运行情况收集性能监控信息，动态调整这些参数**以提供最合适的停顿时间或者最大的吞吐量，这种调节方式称为GC 自适应的调节策略（GC Ergonomics） 。如果读者对于收集器运作原来不太了解，手工优化存在困难的时候，使用Parallel Scavenge收集器配合自适应调节策略，把内存管理的调优任务 交给虚拟机去完成将是一个不错的选择。只需要把基本的内存数据设置好（如-Xmx设置最大 堆），然后使用MaxGCPauseMillis参数（更关注最大停顿时间）或GCTimeRatio（更关注吞 吐量）参数给虚拟机设立一个优化目标，那具体细节参数的调节工作就由虚拟机完成了。自 适应调节策略也是Parallel Scavenge收集器与ParNew收集器的一个重要区别。



### 2. Parallel Old

> ​		Parallel Old是Parallel Scavenge收集器的老年代版本，使用==**多线程**==和==**“标记-整理”**==算法。 这个收集器是在JDK 1.6中才开始提供的。
>
> ​		在此之前，新生代的Parallel Scavenge收集器一直 处于比较尴尬的状态。原因是，如果新生代选择了Parallel Scavenge收集器，老年代除了 Serial Old（PS MarkSweep）收集器外别无选择（还记得上面说过Parallel Scavenge收集器无 法与CMS收集器配合工作吗？）。由于老年代Serial Old收集器在服务端应用性能上的“拖累”，使用了Parallel Scavenge收集器也未必能在整体应用上获得吞吐量最大化的效果，由于 单线程的老年代收集中无法充分利用服务器多CPU的处理能力，在老年代很大而且硬件比较 高级的环境中，这种组合的吞吐量甚至还不一定有ParNew加CMS的组合“给力”。
>
> ​		直到Parallel Old收集器出现后，==**“吞吐量优先”收集器**==终于有了比较名副其实的应用组合，在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old 收集器。Parallel Old收集器的工作过程如图3-9所示。

![image-20200315154024439](/Users/arvin/Library/Application Support/typora-user-images/image-20200315154024439.png)



### 3. CMS收集器

> ​		CMS（Concurrent Mark Sweep）收集器是一种以获取==**最短回收停顿**==时间为目标的收集 器。目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重 视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常 符合这类应用的需求。
>
> ​		从名字（包含“Mark Sweep”）上就可以看出，CMS收集器是基于==**“标记—清除”**==算法实现 的，它的运作过程相对于前面几种收集器来说更复杂一些，整个过程分为4个步骤，包括：
>
> + 初始标记（CMS initial mark） 
>
> + 并发标记（CMS concurrent mark） 
>
> + 重新标记（CMS remark） 
>
> + 并发清除（CMS concurrent sweep） 
>
> ​        其中，初始标记、重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只是 标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC RootsTracing 的过程，而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变 动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远 比并发标记的时间短。
>
> ​        由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起 工作，所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。通 过图3-10可以比较清楚地看到CMS收集器的运作步骤中并发和需要停顿的时间。

![image-20200315164311455](/Users/arvin/Library/Application Support/typora-user-images/image-20200315164311455.png)

> **缺点：**
>
> 1. CMS收集器对CPU资源非常敏感。其实，面向并发设计的程序都对CPU资源比较敏感。 在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程（或者说CPU资 源）而导致应用程序变慢，总吞吐量会降低。CMS默认启动的回收线程数是（CPU数量 +3）/4，也就是当CPU在4个以上时，并发回收时垃圾收集线程不少于25%的CPU资源，并且 随着CPU数量的增加而下降。但是当CPU不足4个（譬如2个）时，CMS对用户程序的影响就 可能变得很大，如果本来CPU负载就比较大，还分出一半的运算能力去执行收集器线程，就 可能导致用户程序的执行速度忽然降低了50%，其实也让人无法接受。为了应付这种情况， 虚拟机提供了一种称为“增量式并发收集器”（Incremental Concurrent Mark Sweep/i-CMS）的 CMS收集器变种，所做的事情和单CPU年代PC机操作系统使用抢占式来模拟多任务机制的思 想一样，就是在并发标记、清理的时候让GC线程、用户线程交替运行，尽量减少GC线程的 独占资源的时间，这样整个垃圾收集的过程会更长，但对用户程序的影响就会显得少一些， 也就是速度下降没有那么明显。实践证明，增量时的CMS收集器效果很一般，在目前版本 中，i-CMS已经被声明为“deprecated”，即不再提倡用户使用。
>
> 2. CMS收集器无法处理浮动垃圾（Floating Garbage），可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。由于CMS并发清理阶段用户线程还在运行着，伴 随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法 在当次收集中处理掉它们，只好留待下一次GC时再清理掉。这一部分垃圾就称为“浮动垃 圾”。也是由于在垃圾收集阶段用户线程还需要运行，那也就还需要预留有足够的内存空间 给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进 行收集，需要预留一部分空间提供并发收集时的程序运作使用。在JDK 1.5的默认设置 下，CMS收集器当老年代使用了68%的空间后就会被激活，这是一个偏保守的设置，如果在 应用中老年代增长不是太快，可以适当调高参数-XX：CMSInitiatingOccupancyFraction的值来 提高触发百分比，以便降低内存回收次数从而获取更好的性能，在JDK 1.6中，CMS收集器 的启动阈值已经提升至92%。要是CMS运行期间预留的内存无法满足程序需要，就会出现一 次“Concurrent Mode Failure”失败，这时虚拟机将启动后备预案：临时启用Serial Old收集器来 重新进行老年代的垃圾收集，这样停顿时间就很长了。所以说参数-XX：CM SInitiatingOccupancyFraction设置得太高很容易导致大量“Concurrent Mode Failure”失败，性能 反而降低。
>
> 3. CMS是一款基于“标记—清除”算法实现的收集 器，如果读者对前面这种算法介绍还有印象的话，就可能想到这意味着收集结束时会有大量 空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次Full GC。为了解决这个问题，CMS收集器提供了一个-XX：+UseCMSCompactAtFullCollection开 关参数（默认就是开启的），用于在CMS收集器顶不住要进行FullGC时开启内存碎片的合并整理过程，内存整理的过程是无法并发的，空间碎片问题没有了，但停顿时间不得不变长。 虚拟机设计者还提供了另外一个参数-XX：CMSFullGCsBeforeCompaction，这个参数是用于 设置执行多少次不压缩的Full GC后，跟着来一次带压缩的（默认值为0，表示每次进入Full GC时都进行碎片整理）。



### 4. G1收集器

> G1（Garbage-First）收集器是当今收集器技术发展的最前沿成果之一，早在JDK 1.7刚刚 确立项目目标，Sun公司给出的JDK 1.7 RoadMap里面，它就被视为JDK 1.7中HotSpot虚拟机 的一个重要进化特征。从JDK 6u14中开始就有Early Access版本的G1收集器供开发人员实 验、试用，由此开始G1收集器的“Experimental”状态持续了数年时间，直至JDK 7u4，Sun公 司才认为它达到足够成熟的商用程度，移除了“Experimental”的标识。
>
> G1是一款面向服务端应用的垃圾收集器。HotSpot开发团队赋予它的使命是（在比较长 期的）未来可以替换掉JDK 1.5中发布的CMS收集器。与其他GC收集器相比，G1具备如下特 点。
>
> 并行与并发：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU（CPU或者 CPU核心）来缩短Stop-The-World停顿的时间，部分其他收集器原本需要停顿Java线程执行的 GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。
>
> 分代收集：与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需要其 他收集器配合就能独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已 经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。
>
> 空间整合：与CMS的“标记—清理”算法不同，G1从整体来看是基于“标记—整理”算法实 现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的，但无论如何，这 两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。这种 特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一 次GC。
>
> 可预测的停顿：这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共同的关 注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一 个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实 时Java（RTSJ）的垃圾收集器的特征了。
>
> 在G1之前的其他收集器进行收集的范围都是整个新生代或者老年代，而G1不再是这 样。使用G1收集器时，Java堆的内存布局就与其他收集器有很大差别，它将整个Java堆划分 为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和 老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。
>
> G1收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个Java 堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的 空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时 间，优先回收价值最大的Region（这也就是Garbage-First名称的来由）。这种使用Region划分 内存空间以及有优先级的区域回收方式，保证了G1收集器在有限的时间内可以获取尽可能高 的收集效率。
>
> G1把内存“化整为零”的思路，理解起来似乎很容易，但其中的实现细节却远远没有想象 中那样简单，否则也不会从2004年Sun实验室发表第一篇G1的论文开始直到今天（将近10年 时间）才开发出G1的商用版。笔者以一个细节为例：把Java堆分为多个Region后，垃圾收集 是否就真的能以Region为单位进行了？听起来顺理成章，再仔细想想就很容易发现问题所 在：Region不可能是孤立的。一个对象分配在某个Region中，它并非只能被本Region中的其 他对象引用，而是可以与整个Java堆任意的对象发生引用关系。那在做可达性判定确定对象 是否存活的时候，岂不是还得扫描整个Java堆才能保证准确性？这个问题其实并非在G1中才 有，只是在G1中更加突出而已。在以前的分代收集中，新生代的规模一般都比老年代要小许 多，新生代的收集也比老年代要频繁许多，那回收新生代中的对象时也面临相同的问题，如 果回收新生代时也不得不同时扫描老年代的话，那么Minor GC的效率可能下降不少。
>
> 在G1收集器中，Region之间的对象引用以及其他收集器中的新生代与老年代之间的对象 引用，虚拟机都是使用Remembered Set来避免全堆扫描的。G1中每个Region都有一个与之对 应的Remembered Set，虚拟机发现程序在对Reference类型的数据进行写操作时，会产生一个 Write Barrier暂时中断写操作，检查Reference引用的对象是否处于不同的Region之中（在分代 的例子中就是检查是否老年代中的对象引用了新生代中的对象），如果是，便通过 CardTable把相关引用信息记录到被引用对象所属的Region的Remembered Set之中。当进行内 存回收时，在GC根节点的枚举范围中加入Remembered Set即可保证不对全堆扫描也不会有遗 漏。
>
> 如果不计算维护Remembered Set的操作，G1收集器的运作大致可划分为以下几个步骤： 初始标记（Initial Marking） 并发标记（Concurrent Marking） 最终标记（Final Marking） 筛选回收（Live Data Counting and Evacuation） 对CMS收集器运作过程熟悉的读者，一定已经发现G1的前几个步骤的运作过程和CMS 有很多相似之处。初始标记阶段仅仅只是标记一下GC Roots能直接关联到的对象，并且修改 TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的 Region中创建新对象，这阶段需要停顿线程，但耗时很短。并发标记阶段是从GC Root开始 对堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但可与用户程序并发执 行。而最终标记阶段则是为了修正在并发标记期间因用户程序继续运作而导致标记产生变动 的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remembered Set Logs里面，最 终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这阶段需要停顿线 程，但是可并行执行。最后在筛选回收阶段首先对各个Region的回收价值和成本进行排序， 根据用户所期望的GC停顿时间来制定回收计划，从Sun公司透露出来的信息来看，这个阶段 其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控 制的，而且停顿用户线程将大幅提高收集效率。通过图3-11可以比较清楚地看到G1收集器的 运作步骤中并发和需要停顿的阶段。

![image-20200315165429692](/Users/arvin/Library/Application Support/typora-user-images/image-20200315165429692.png)



# 3. 类加载



# 4. 内存中的对象



# 5. 并发 & 锁



# 6. JVM调优参数



> -X ：非标准选项
>
> -XX：非稳定选项
>
>  
>
> 在选项名前用 “+” 或 “-” 表示开启或关闭特定的选项，例：
>
>   -XX:+UseCompressedOops：表示开启 压缩指针
>
>   -XX:-UseCompressedOops：表示关闭 压缩指针



### 1. 堆分配参数

-Xmn10M：设置新生代区域大小为10M

-XX:NewSize=2M：设置新生代初始大小为2M

-XX:MaxNewSize=2M：设置新生代最大值为2M

> 如果以上三个同时设置了，谁在后面谁生效。生产环境使用-Xmn即可，避免抖动

==-Xms128M：设置java程序启动时堆内存128M（默认为物理内存1/64,且小于1G）==

==-Xmx256M：设置最大堆内存256M，超出后会出现 OutOfMemoryError（默认为物理内存1/64,且小于1G）==

> 生产环境 -Xms 与 -Xmx 最好一样，避免抖动

==-Xss1M：设置线程栈的大小 1M（默认1M）==

-XX:ThreadStackSize，-Xss 设置在后面，以-Xss为准；  -XX:ThreadStackSize设置在后面，主线程以 -Xss为准，其他线程以  -XX:ThreadStackSize为准

-XX:MinHeapFreeRatio=40：设置堆空间最小空闲比例（默认40）（当-Xmx与-Xms相等时，该配置无效）

-XX:MaxHeapFreeRatio=70：设置堆空间最大空闲比例（默认70）（当-Xmx与-Xms相等时，该配置无效）

-XX:NewRatio=2：设置年轻代与年老代的比例为2:1

==-XX:SurvivorRatio=8：设置年轻代中eden区与survivor区的比例为8：1==

==-XX:MetaspaceSize=64M：设置元数据空间初始大小（取代-XX:PermSize）==

==-XX:MaxMetaspaceSize=128M：设置元数据空间最大值（取代之前-XX:MaxPermSize）==

-XX:TargetSurvivorRatio=50：设置survivor区使用率。当survivor区达到50%时，将对象送入老年代

-XX:+UseTLAB：在年轻代空间中使用本地线程分配缓冲区(TLAB)，默认开启

-XX:TLABSize=512k：设置TLAB大小为512k

-XX:+UseCompressedOops：使用压缩指针，默认开启



### 2. 垃圾回收器相关

==-XX:MaxTenuringThreshold=15：对象进入老年代的年龄（Parallel是15，CMS是6）==

==-XX:PretenureSizeThreshold：令大于这个设置值的对象直接在老 年代分配==

==HandlePromotionFailure：是否允许担保失败==

-XX:MaxGCPauseMillis：设置最大垃圾收集停顿时间（收集器工作时会调整其他参数大小，尽可能将停顿控制在指定时间内）

-XX:+UseAdaptiveSizePolicy：打开自适应GC策略（该摸式下，各项参数都会被自动调整）

-XX:+UseSerialGC：在年轻代和年老代使用串行回收器


-XX:+UseParallelGC：使用并行垃圾回收收集器，默认会同时启用 -XX:+UseParallelOldGC（默认使用该回收器）

-XX:+UseParallelOldGC：开启老年代使用并行垃圾收集器，默认会同时启用 -XX:+UseParallelGC

-XX:ParallelGCThreads=4：设置用于垃圾回收的线程数为4（默认与CPU数量相同）


-XX:+UseConcMarkSweepGC：使用CMS收集器（年老代）

-XX:CMSInitiatingOccupancyFraction=80：设置CMS收集器在年老代空间被使用多少后触发

-XX:+CMSClassUnloadingEnabled：允许对类元数据进行回收

-XX:+UseCMSInitiatingOccupancyOnly：只在达到阈值的时候，才进行CMS回收


-XX:+UseG1GC：使用G1回收器

-XX:G1HeapRegionSize=16m：使用G1收集器时设置每个Region的大小（范围1M - 32M）

-XX:MaxGCPauseMillis=500 ：设置最大暂停时间（毫秒）


-XX:+DisableExplicitGC：禁止显示GC的调用（即禁止开发者的 System.gc();）

 

### 2. GC日志

==-XX:+PrintGCApplicationStoppedTime 会打出系统停止的时间==

==-XX:+PrintSafepointStatistics -XX:PrintSafepointStatisticsCount=1 这两个参数会打印出详细信息==

-XX:+PrintGCDetails：打印GC信息

-XX:+PrintGCTimeStamps ：打印每次GC的时间戳（现在距离启动的时间长度）

-XX:+PrintGCDateStamps ：打印GC日期

-XX:+PrintHeapAtGC：每次GC时，打印堆信息

-Xloggc:/usr/local/tomcat/logs/gc.$$.log ：GC日志存放的位置



### 3. 堆快照
-XX:+HeapDumpOnOutOfMemoryError：出现内存溢出时存储堆信息，配合 -XX:HeapDumpPath 使用

-XX:HeapDumpPath=/usr/local/tomcat/logs/oom.%t.log：堆快照存储位置

-XX:+UseLargePages：使用大页  

-XX:LargePageSizeInBytes=4m：指定大页的大小（必须为2的幂）



### 4. 滚动日志记录
-XX:+UseGCLogFileRotation  ： 开启滚动日志记录

-XX:NumberOfGCLogFiles=5 ：滚动数量，命名为filename.0, filename.1 .....  filename.n-1,  然后再从filename.0 开始，并覆盖已经存在的文件

-XX:GCLogFileSize=8k  :  每个文件大小，当达到该指定大小时，会写入下一个文件

-Xloggc:/gc/log   ：日志文件位置