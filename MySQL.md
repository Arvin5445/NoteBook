[TOC]

# 1. MyISAM 与 InnoDB 的区别

https://blog.csdn.net/qq_35642036/article/details/82820178

1. InnoDB支持==事务==，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务； 

2. InnoDB支持==外键==，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败； 

3. InnoDB是==聚集索引==，使用B+Tree作为索引结构，==数据文件是和（主键）索引绑在一起的==（表数据文件本身就是按B+Tree组织的一个索引结构），必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。

   > MySQL的MyISAM除外，此存储引擎的聚集索引和非聚集索引只多了个唯一约束，其他没什么区别
   >
   > MyISAM是非聚集索引，也是使用B+Tree作为索引结构，索引和数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。
   >
   > 也就是说：InnoDB的B+树主键索引的叶子节点就是数据文件，辅助索引的叶子节点是主键的值；而MyISAM的B+树主键索引和辅助索引的叶子节点都是数据文件的地址指针。

   

   > 聚集索引和非聚集索引的根本区别：
   >
   > 1. 表记录的排列顺序和与索引的排列顺序是否一致。
   > 2. 聚集索引一个表只有一个，非聚集索引一个表可以存在多个。
   > 3. 聚集索引存储记录是物理上连续存在，非聚集索引是逻辑上的连续。
   >
   > 拼音目录  部首目录

   

4. ==InnoDB不保存表的具体行数==，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快（注意不能加有任何WHERE条件）；

   > 那么为什么InnoDB没有了这个变量呢？
   >
   > ​		因为InnoDB的事务特性，在同一时刻表中的行数对于不同的事务而言是不一样的，因此count统计会计算对于当前事务而言可以统计到的行数，而不是将总行数储存起来方便快速查询。
   >
   > ​		InnoDB会尝试遍历一个尽可能小的索引除非优化器提示使用别的索引。如果二级索引不存在，InnoDB还会尝试去遍历其他聚簇索引。
   > ​		如果索引并没有完全处于InnoDB维护的缓冲区（Buffer Pool）中，count操作会比较费时。可以建立一个记录总行数的表并让你的程序在INSERT/DELETE时更新对应的数据。
   >
   > ​		和上面提到的问题一样，如果此时存在多个事务的话这种方案也不太好用。如果得到大致的行数值已经足够满足需求可以尝试SHOW TABLE STATUS

   

5. Innodb不支持==全文索引==，而MyISAM支持全文索引，在涉及全文索引领域的查询效率上MyISAM速度更快高；PS：5.7以后的InnoDB支持全文索引了

6. MyISAM表格可以被压缩后进行查询操作

7. ==InnoDB支持表、行(默认)级锁，而MyISAM支持表级锁==

> InnoDB的行锁是实现在索引上的，而不是锁在物理行记录上。潜台词是，如果访问没有命中索引，也无法使用行锁，将要退化为表锁。

  

8. InnoDB表==必须有主键==（用户没有指定的话会自己找或生产一个主键），而Myisam可以没有

9. Innodb存储文件有frm、ibd，而Myisam是frm、MYD、MYI

   > Innodb：frm是表定义文件，ibd是数据文件
   > Myisam：frm是表定义文件，myd是数据文件，myi是索引文件



**如何选择：**

    1. 是否要支持事务，如果要请选择innodb，如果不需要可以考虑MyISAM；
    
    2. 如果表中绝大多数都只是读查询，可以考虑MyISAM，如果既有读也有写，请使用InnoDB。
    
    3. 系统奔溃后，MyISAM恢复起来更困难，能否接受；
    
    4. MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)，说明其优势是有目共睹的，如果你不知道用什么，那就用InnoDB，至少不会差。



**InnoDB为什么推荐使用自增ID作为主键？**

    答：自增ID可以保证每次插入时B+索引是从右边扩展的，可以避免B+树和频繁合并和分裂（对比使用UUID）。如果使用字符串主键和随机主键，会使得数据随机插入，效率比较差。



**innodb引擎的4大特性**

       插入缓冲（insert buffer),二次写(double write),自适应哈希索引(ahi),预读(read ahead)





# 2. explain 执行计划

https://www.cnblogs.com/tufujie/p/9413852.html

**type:**

对表访问方式，表示MySQL在表中找到所需行的方式，又称“访问类型”。

常用的类型有： **ALL、index、range、 ref、eq_ref、const、system、NULL**（从左到右，性能从差到好）

**ALL:** Full Table Scan， MySQL将遍历全表以找到匹配的行

**index:** Full Index Scan，index与ALL区别为index类型只遍历索引树

**range:**只检索给定范围的行，使用一个索引来选择行

**ref:** 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值

**eq_ref:** 类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件

**const、system:** 当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量，system是const类型的特例，当查询的表只有一行的情况下，使用system

**NULL:** MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。





# 3. 锁

### 乐观锁

```mysql
1. SELECT data AS old_data, version AS old_version FROM t;

2. -- 根据获取的数据进行业务操作，得到new_data和new_version

3. UPDATE SET data = new_data, version = new_version WHERE version = old_version

4. if (updated row > 0) {
    	-- 乐观锁获取成功，操作完成
   } else {
    	-- 乐观锁获取失败，回滚并重试
   }
```



### 悲观锁

```mysql
-- 开始事务（三者选一个）
begin;/begin work;/start transaction;

-- 关闭自动提交
set autocommit=off

-- 使用了select...for update方式，通过开启排他锁的方式实现了悲观锁。则相应的记录被锁定，其他事务必须等本次事务提交之后才能够执行
select status from t_goods where id=1 for update;

-- 根据商品信息生成订单
insert into t_orders (id,goods_id) values (null,1);

-- 修改商品status为2
update t_goods set status=2;

-- 提交事务
commit;/commit work;
```





# 4. 索引

一种加速查询的数据结构（空间换时间）



### 索引类型


Mysql目前主要有以下几种索引类型：**FULLTEXT，HASH，BTREE，RTREE**。

1. FULLTEXT

   ​		即为全文索引，目前只有MyISAM，InnoDB 5.7 引擎支持。其可以在CREATE TABLE ，ALTER TABLE ，CREATE INDEX 使用，不过目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引。
   全文索引并不是和MyISAM一起诞生的，它的出现是为了解决WHERE name LIKE “%word%"这类针对文本的模糊查询效率较低的问题。

2. HASH

   ​		由于HASH的唯一（几乎100%的唯一）及类似键值对的形式，很适合作为索引。
   HASH索引可以一次定位，不需要像树形索引那样逐层查找,因此具有极高的效率。但是，这种高效是有条件的，即只在“=”和“in”条件下高效，对于范围查询、排序及组合索引仍然效率不高。

   > B+ Tree索引和Hash索引区别？
   >
   > 哈希索引适合等值查询，但是无法进行**范围查询** 
   >
   > 哈希索引没办法利用索引完成**排序** 
   >
   > 哈希索引不支持多列**联合**索引的最左匹配规则 
   >
   > 如果有大量重复键值的情况下，哈希索引的效率会很低，因为存在哈希碰撞问题

3. BTREE（InnoDB支持）

   ​		BTREE索引就是一种将索引值按一定的算法，存入一个树形的数据结构中（二叉树），每次查询都是从树的入口root开始，依次遍历node，获取leaf。这是MySQL里默认和最常用的索引类型。

4. RTREE

   ​		RTREE在MySQL很少使用，仅支持geometry数据类型，支持该类型的存储引擎只有MyISAM、BDb、InnoDb、NDb、Archive几种。相对于BTREE，RTREE的优势在于范围查找。
   
   

![img](https://img-blog.csdn.net/20170819204028172?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZG9jdG9yX3dobzIwMDQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)



### ==**聚集索引和非聚集索引**==

> 聚集索引和非聚集索引的根本区别：
>
> 1. 表记录的排列顺序和与索引的排列顺序是否一致。
> 2. 聚集索引一个表只有一个，非聚集索引一个表可以存在多个。
> 3. 聚集索引存储记录是物理上连续存在，非聚集索引是逻辑上的连续。
>
> 拼音目录  部首目录

> **Q：****刚刚我们聊到B+ Tree ，那你知道B+ Tree的叶子节点都可以存哪些东西吗？**
>
> **A：**InnoDB的B+ Tree可能存储的是整行数据（主键索引），也有可能是索引值和主键值（非主键索引）
>
> **Q：****那这两者有什么区别吗？** 
>
> **A：**（当他问我叶子节点的时候，其实我就猜到他可能要问我聚簇索引和非聚簇索引了）在 InnoDB 里，索引B+ Tree的叶子节点存储了整行数据的是主键索引，也被称之为聚簇索引。而索引B+ Tree的叶子节点存储了主键的值的是非主键索引，也被称之为非聚簇索引
>
> **Q：****那么，聚簇索引和非聚簇索引，在查询数据的时候有区别吗？**
>
> **A：**聚簇索引查询会更快？
>
> **Q：****为什么呢？** 
>
> **A：**因为主键索引树的叶子节点直接就是我们要查询的整行数据了。而非主键索引的叶子节点是主键的值，查到主键的值以后，还需要再通过主键的值再进行一次查询
>
> **Q：****刚刚你提到主键索引查询只会查一次，而非主键索引需要回表查询多次。（后来我才知道，原来这个过程叫做\**回表\**）是所有情况都是这样的吗？非主键索引一定会查询多次吗？**
>
> **A：**（额、这个问题我回答的不好，后来我自己查资料才知道，通过**覆盖索引**也可以只查询一次）
>
> 覆盖索引（covering index）指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。也可以称之为实现了索引覆盖。
>
> 当一条查询语句符合覆盖索引条件时，MySQL只需要通过索引就可以返回查询所需要的数据，这样避免了查到索引后再返回表操作，减少I/O提高效率。
>
> 如，表covering_index_sample中有一个普通索引 idx_key1_key2(key1,key2)。
>
> 当我们通过SQL语句：select key2 from covering_index_sample where key1 = 'keytest';的时候，就可以通过覆盖索引查询，无需回表。
>
> 
>
### **==联合索引、最左前缀匹配==**
>
> 
>**为什么要使用联合索引**
> 
>**减少开销。**建一个联合索引(col1,col2,col3)，实际相当于建了(col1),(col1,col2),(col1,col2,col3)三个索引。每多一个索引，都会增加写操作的开销和磁盘空间的开销。对于大量数据的表，使用联合索引会大大的减少开销！
> 
>**覆盖索引。**对联合索引(col1,col2,col3)，如果有如下的sql: select col1,col2,col3 from test where col1=1 and col2=2。那么MySQL可以直接通过遍历索引取得数据，而无需回表，这减少了很多的随机io操作。减少io操作，特别的随机io其实是dba主要的优化策略。所以，在真正的实际应用中，覆盖索引是主要的提升性能的优化手段之一。
> 
>**效率高。**索引列越多，通过索引筛选出的数据越少。有1000W条数据的表，有如下sql:select from table where col1=1 and col2=2 and col3=3,假设假设每个条件可以筛选出10%的数据，如果只有单值索引，那么通过该索引能筛选出1000W10%=100w条数据，然后再回表从100w条数据中找到符合col2=2 and col3= 3的数据，然后再排序，再分页；如果是联合索引，通过索引筛选出1000w10% 10% *10%=1w，效率提升可想而知！
> 
>Q：****不知道的话没关系，想问一下，你们在创建索引的时候都会考虑哪些因素呢？**
> 
>**A：**我们一般对于查询概率比较高，经常作为where条件的字段设置索引
> 
>**Q：** **那你们有用过联合索引吗？** 
> 
>**A：**用过呀，我们有对一些表中创建过联合索引
> 
>**Q：****那你们在创建联合索引的时候，需要做联合索引多个字段之间顺序你们是如何选择的呢？** 
> 
>**A：**我们把识别度最高的字段放到最前面
> 
>**Q：****为什么这么做呢？**
> 
>**A：**（这个问题有点把我问蒙了，稍微有些慌乱）这样的话可能命中率会高一点吧。。。
> 
>**Q：** **那你知道最左前缀匹配吗？**
> 
>**A：**（我突然想起来原来面试官是想问这个，怪自己刚刚为什么就没想到这个呢。）哦哦哦。您刚刚问的是这个意思啊，在创建多列索引时，我们根据业务需求，where子句中使用最频繁的一列放在最左边，因为MySQL索引查询会遵循最左前缀匹配的原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。所以当我们创建一个联合索引的时候，如(key1,key2,key3)，相当于创建了（key1）、(key1,key2)和(key1,key2,key3)三个索引，这就是最左匹配原则



### 索引分类

**普通索引**

> 最基本的索引，它没有任何限制，用于加速查询。

**主键索引**

> 是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值。一般是在建表的时候同时创建主键索引。

**唯一索引**

> 索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。

**组合索引**

> 指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用组合索引时遵循最左前缀集合。

**全文索引**

> 主要用来查找文本中的关键字，而不是直接与索引中的值相比较。
>
> fulltext索引跟其它索引大不相同，它更像是一个搜索引擎，而不是简单的where语句的参数匹配。
>
> fulltext索引配合match against操作使用，而不是一般的where语句加like。
>
> 它可以在create table，alter table ，create index使用，不过目前只有char、varchar，text 列上可以创建全文索引。





# 5. 事务

> ==当autocommit为开启状态时（默认开启）==
>
> 即使没有手动start transaction开启事务，mysql默认也会将用户的操作当做事务即时提交。怎么理解呢？例如，你执行了insert into test values(2)语句，mysql默认会帮你开启事务，并且在这条插入语句执行完成之后，默认帮你提交事务。
>
> 当autocommit为ON的情况下，并且又手动开启了事务，那么mysql会把start transaction 与 commit之间的语句当做一次事务来处理，默认并不会帮用户提交需要手动提交，如果用户不提交便退出了，那么事务将回滚。
>
> ==autocommit设置为OFF之后==
>
> 系统默认开始了事务，但是并不会默认帮你提交事务



## 1. InnoDB的四种事务隔离级别

SQL标准定义的四个隔离级别为：

1.  read uncommited ：**读未提交**  读到未提交数据（脏读）

2.  read committed：**读提交**  别人提交的前后，我读出来的内容可能不一样（不可重复读）

3.  repeatable read：**可重复读（InnoDB默认）** 别人提交了我也看不到 （幻读）

4.  serializable ：**串行化** 

   ​		对于同一个数据来说，在同一个时间段内，只能有一个会话可以访问，包括select和dml，通过执行事务串行执行，避免幻读问题；

   　　也就是说，对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。



## 2. MYSQL支持事务吗？

在缺省模式下，MYSQL是autocommit模式的，所有的数据库更新操作都会即时提交。

如果你的MYSQL表类型是使用InnoDB Tables 或 BDB tables的话（默认InnoDB），你的MYSQL就可以使用事务处理,使用SET AUTOCOMMIT=0就可以使MYSQL允许在非autocommit模式，在非autocommit模式下，你必须使用COMMIT来提交你的更改，或者用ROLLBACK来回滚你的更改。



## 3. 事务介绍（特性）

事务（transaction）是作为一个单元的一组有序的数据库操作。如果组中的所有操作都成功，则认为事务成功，即使只有一个操作失败，事务也不成功。如果所有操作完成，事务则提交，其修改将作用于所有其他数据库进程。如果一个操作失败，则事务将回滚，该事务所有操作的影响都将取消。

**事务特性：**

（1）原子性：即不可分割性，事务要么全部被执行，要么就全部不被执行。

（2）一致性或可串性。事务的执行使得数据库从一种正确状态转换成另一种正确状态（完整性约束）

（3）隔离性。在事务正确提交之前，不允许把该事务对数据的任何改变提供给任何其他事务，

（4） 持久性。事务正确提交后，其结果将永久保存在数据库中，即使在事务提交后有了其他故障，事务的处理结果也会得到保存。

或者这样理解：

事务就是被绑定在一起作为一个逻辑工作单元的SQL语句分组，如果任何一个语句操作失败那么整个操作就被失败，以后操作就会回滚到操作前状态，或者是上有个节点。为了确保要么执行，要么不执行，就可以使用事务。要将有组语句作为事务考虑，就需要通过ACID测试，即原子性，一致性，隔离性和持久性。



## 4. Myql中的事务回滚机制概述

事务是用户定义的一个数据库操作序列，这些操作要么全做要么全不做，是一个不可分割的工作单位，事务回滚是指将该事务已经完成的对数据库的更新操作撤销。

要同时修改数据库中两个不同表时，如果它们不是一个事务的话，当第一个表修改完，可能第二个表修改过程中出现了异常而没能修改，此时就只有第二个表依旧是未修改之前的状态，而第一个表已经被修改完毕。而当你把它们设定为一个事务的时候，当第一个表修改完，第二表修改出现异常而没能修改，第一个表和第二个表都要回到未修改的状态，这就是所谓的事务回滚



## 5. 事务的实现原理

***\*问题一：Mysql怎么保证一致性的？\****
OK，这个问题分为两个层面来说。
从数据库层面，数据库通过原子性、隔离性、持久性来保证一致性。也就是说ACID四大特性之中，C(一致性)是目的，A(原子性)、I(隔离性)、D(持久性)是手段，是为了保证一致性，数据库提供的手段。数据库必须要实现AID三大特性，才有可能实现一致性。例如，原子性无法保证，显然一致性也无法保证。

但是，如果你在事务里故意写出违反约束的代码，一致性还是无法保证的。例如，你在转账的例子中，你的代码里故意不给B账户加钱，那一致性还是无法保证。因此，还必须从应用层角度考虑。

从应用层面，通过代码判断数据库数据是否有效，然后决定回滚还是提交数据！

***\*问题二: Mysql怎么保证原子性的？\****
OK，是利用Innodb的undo log。
undo log名为回滚日志，是实现原子性的关键，当事务回滚时能够撤销所有已经成功执行的sql语句，他需要记录你要回滚的相应日志信息。
例如

1、当你delete一条数据的时候，就需要记录这条数据的信息，回滚的时候，insert这条旧数据

2、当你update一条数据的时候，就需要记录之前的旧值，回滚的时候，根据旧值执行update操作

3、当年insert一条数据的时候，就需要这条记录的主键，回滚的时候，根据主键执行delete操作

undo log记录了这些回滚需要的信息，当事务执行失败或调用了rollback，导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子。

ps:具体的undo log日志长啥样，这个可以写一篇文章了。而且写出来，看的人也不多，姑且先这么简单的理解吧。

***\*问题三: Mysql怎么保证持久性的？\****
OK，是利用Innodb的redo log。
正如之前说的，Mysql是先把磁盘上的数据加载到内存中，在内存中对数据进行修改，再刷回磁盘上。如果此时突然宕机，内存中的数据就会丢失。
怎么解决这个问题？
简单啊，事务提交前直接把数据写入磁盘就行啊。
这么做有什么问题？

- 只修改一个页面里的一个字节，就要将整个页面刷入磁盘，太浪费资源了。毕竟一个页面16kb大小，你只改其中一点点东西，就要将16kb的内容刷入磁盘，听着也不合理。
- 毕竟一个事务里的SQL可能牵涉到多个数据页的修改，而这些数据页可能不是相邻的，也就是属于随机IO。显然操作随机IO，速度会比较慢。

于是，决定采用redo log解决上面的问题。当做数据修改的时候，不仅在内存中操作，还会在redo log中记录这次操作。当事务提交的时候，会将redo log日志进行刷盘(redo log一部分在内存中，一部分在磁盘上)。当数据库宕机重启的时候，会将redo log中的内容恢复到数据库中，再根据undo log和binlog内容决定回滚数据还是提交数据。

采用redo log的好处？
其实好处就是将redo log进行刷盘比对数据页刷盘效率高，具体表现如下

- redo log体积小，毕竟只记录了哪一页修改了啥，因此体积小，刷盘快。
- redo log是一直往末尾进行追加，属于顺序IO。效率显然比随机IO来的快。

ps:不想具体去谈redo log具体长什么样，因为内容太多了。

***\*问题四: Mysql怎么保证隔离性的？\****
OK,利用的是锁和MVCC机制。还是拿转账例子来说明，有一个账户表如下
表名t_balance

![640?wx_fmt=png](https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/SYoYmIOcI5oc7c7gqDQh2yS1Wv3DWvQuk8zL2drcNJmibDibOjo43U58RKicfYkuZ4Ekcot5vrxL6RCE08XmhJ6Xg/640?wx_fmt=png)

其中id是主键，user_id为账户名，balance为余额。还是以转账两次为例，如下图所示

![640?wx_fmt=jpeg](https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/SJm51egHPPF54Qq1YT4Q3rPCwJCMYqUeCbm2eAfGPYX3wUZicD3cvs4TlzgPjG3KVlaFB38RPtWsAjVHgCeLHMw/640?wx_fmt=jpeg)

至于MVCC,即多版本并发控制(Multi Version Concurrency Control),一个行记录数据有多个版本对快照数据，这些快照数据在undo log中。

如果一个事务读取的行正在做DELELE或者UPDATE操作，读取操作不会等行上的锁释放，而是读取该行的快照版本。
由于MVCC机制在可重复读(Repeateable Read)和读已提交(Read Commited)的MVCC表现形式不同，就不赘述了。
但是有一点说明一下，在事务隔离级别为读已提交(Read Commited)时，一个事务能够读到另一个事务已经提交的数据，是不满足隔离性的。但是当事务隔离级别为可重复读(Repeateable Read)中，是满足隔离性的。





# 6. B树与B+树

## B树

b树（balance tree）和b+树应用在数据库索引，可以认为是m叉的多路平衡查找树，但是从理论上讲，二叉树查找速度和比较次数都是最小的，为什么不用二叉树呢？ 
因为我们要考虑磁盘IO的影响，它相对于内存来说是很慢的。数据库索引是存储在磁盘上的，当数据量大时，就不能把整个索引全部加载到内存了，只能逐一加载每一个磁盘页（对应索引树的节点）。所以我们要减少IO次数，对于树来说，IO次数就是树的高度，而“矮胖”就是b树的特征之一，它的每个节点最多包含m个孩子，m称为b树的阶，m的大小取决于磁盘页的大小。

+ 一个M阶的b树具有如下几个特征：

1. 定义任意非叶子结点最多只有M个儿子，且M>2；
2. 根结点的儿子数为[2, M]；
3. 除根结点以外的非叶子结点的儿子数为[M/2, M]，向上取整；
4. 非叶子结点的关键字个数=儿子数-1；
5. 所有叶子结点位于同一层；
6. k个关键字把节点拆成k+1段，分别指向k+1个儿子，同时满足查找树的大小关系。

+ 有关b树的一些特性，注意与后面的b+树区分：

1. 关键字集合分布在整颗树中；
2. 任何一个关键字出现且只出现在一个结点中；
3. 搜索有可能在非叶子结点结束；
4. 其搜索性能等价于在关键字全集内做一次二分查找；

![img](https://img2018.cnblogs.com/blog/271805/201812/271805-20181204144015524-505027471.png)



## B+树

b+树，是b树的一种变体，查询性能更好。m阶的b+树的特征：

1. 有n棵子树的非叶子结点中含有n个关键字（b树是n-1个），这些关键字不保存数据，只用来索引，所有数据都保存在叶子节点（b树是每个关键字都保存数据）。
2. 所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。
3. 所有的非叶子结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。
4. 通常在b+树上有两个头指针，一个指向根结点，一个指向关键字最小的叶子结点。
5. 同一个数字会在不同节点中重复出现，根节点的最大元素就是b+树的最大元素。

![img](https://img2018.cnblogs.com/blog/271805/201812/271805-20181204144028898-1887549627.png)

**B+树有更高的查找效率（尤其是顺序和范围）**

1. B+树中间节点没有卫星数据，只有索引，而Ｂ树每个结点中的每个关键字都有卫星数据；这就意味着同样的大小的磁盘页可以容纳更多节点元素，在相同的数据量下，Ｂ＋树更加“矮胖”，IO操作更少 。

2. 其次，因为卫星数据的不同，导致查询过程也不同；Ｂ树的查找只需找到匹配元素即可，最好情况下查找到根节点，最坏情况下查找到叶子结点，所说性能很不稳定，而Ｂ＋树每次必须查找到叶子结点，性能稳定。

3. 在范围查询方面，B+树的优势更加明显

   > ​		B树的范围查找需要不断依赖中序遍历。首先二分查找到范围下限，在不断通过中序遍历，知道查找到范围的上限即可。整个过程比较耗时。
   > 　　而B+树的范围查找则简单了许多。首先通过二分查找，找到范围下限，然后同过叶子结点的链表顺序遍历，直至找到上限即可，整个过程简单许多，效率也比较高。



# 7. count(*)

在数据量达到10万以上的级别我们讨论这个问题才有意义.

count(*)包括了所有的列，相当于所有的行数，在统计结果的时候，不会忽略列值为NULL的行数统计，理论上会比较慢

count(1) 中1代表第一列，在统计结果的时候，不会忽略列值为NULL的行数统计

count(列名)只统计包括列名那一列，在统计结果的时候，会忽略列值为null的行数计数，即某个字段值为NULL时，不统计

所以：

 

列名为主键，count(列名)会比count(1)快，当然，第一列为主键则一样快

列名不为主键，count(1)会比count(列名)快，当然，列比较多的情况下

如果表多个列并且没有主键，则 count（1） 肯定快于 count（*）

如果有主键，则 select count（主键）的执行效率是最优的

count（1），count（列），count(*) 在列有null值得情况下，结果会不一样



# 8. 视图

### 数据库视图的优点

以下是使用数据库视图的优点 -

- 数据库视图允许简化复杂查询：数据库视图由与许多基础表相关联的SQL语句定义。 您可以使用数据库视图来隐藏最终用户和外部应用程序的基础表的复杂性。 通过数据库视图，您只需使用简单的SQL语句，而不是使用具有多个连接的复杂的SQL语句。
- 数据库视图有助于限制对特定用户的数据访问。 您可能不希望所有用户都可以查询敏感数据的子集。可以使用数据库视图将非敏感数据仅显示给特定用户组。
- 数据库视图提供额外的安全层。 安全是任何关系数据库管理系统的重要组成部分。 数据库视图为数据库管理系统提供了额外的安全性。 数据库视图允许您创建只读视图，以将只读数据公开给特定用户。 用户只能以只读视图检索数据，但无法更新。
- 数据库视图启用计算列。 数据库表不应该具有计算列，但数据库视图可以这样。 假设在`orderDetails`表中有`quantityOrder`(产品的数量)和`priceEach`(产品的价格)列。 但是，`orderDetails`表没有一个列用来存储订单的每个订单项的总销售额。如果有，数据库模式不是一个好的设计。 在这种情况下，您可以创建一个名为`total`的计算列，该列是`quantityOrder`和`priceEach`的乘积，以表示计算结果。当您从数据库视图中查询数据时，计算列的数据将随机计算产生。
- 数据库视图实现向后兼容。 假设你有一个中央数据库，许多应用程序正在使用它。 有一天，您决定重新设计数据库以适应新的业务需求。删除一些表并创建新的表，并且不希望更改影响其他应用程序。在这种情况下，可以创建与将要删除的旧表相同的模式的数据库视图。



### 数据库视图的缺点

除了上面的优点，使用数据库视图有几个缺点：

- 性能：从数据库视图查询数据可能会很慢，特别是如果视图是基于其他视图创建的。
- 表依赖关系：将根据数据库的基础表创建一个视图。每当更改与其相关联的表的结构时，都必须更改视图。



# 9. 完整性约束

### 数据的完整性

约束是用来确保数据的准确性和一致性。数据的完整性就是对数据的准确性和一致性的一种保证。

数据完整性(Data Integrity)是指数据的精确(Accuracy)和可靠性(Reliability)。

分为以下四类：

**1) 实体完整性**：规定表的每一行在表中是惟一的实体。

**2) 域完整性：**是指表中的列必须满足某种特定的数据类型约束，其中约束又包括取值范围、精度等规定。

**3) 参照完整性**：是指两个表的[主关键字](https://baike.baidu.com/item/主关键字)和[外关键字](https://baike.baidu.com/item/外关键字/1239625)的数据应一致，保证了表之间的数据的一致性，防止了数据丢失或无意义的数据在数据库中扩散。

**4) 用户定义的完整性**：不同的[关系数据库系统](https://baike.baidu.com/item/关系数据库系统)根据其应用环境的不同，往往还需要一些特殊的约束条件。用户定义的完整性即是针对某个特定关系数据库的约束条件，它反映某一具体应用必须满足的语义要求。